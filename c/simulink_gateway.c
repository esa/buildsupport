/* Buildsupport is (c) 2008-2015 European Space Agency
 * contact: maxime.perrotin@esa.int
 * License is LGPL, check LICENSE file */
/*

SIMULINK gateway based on the assert interface view
1st Author: Dimitrios Mylonas/ESA
Updates: Marie-Aude Esteve/ESA
         Daniel Tuulik IB Krates

  updated 20/04/2009 to disable in case "-onlycv" flag is set
  updated 31/12/2014 add blocks parameters required in newer Simulink

*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <assert.h>
#include <stdbool.h>
#include "my_types.h"
#include "practical_functions.h"

/*
 * function:    isBasicType()
 * arguments:   ASN1_basic_type , which the type under research
 * returns:     integer as an answer (1) if the type is basic
 *                                   (0) if the type is composite
 *                                   (-1) in case of a problem
 */
int isOfBasicType(Parameter * theParameter)
{
    int ans = -1;               /* setting answer by default to -1. */

    switch (theParameter->basic_type) {
        case sequenceof:
        case sequence:
        case set:
        case setof:
        case octetstring:
        case choice:
            ans = 0;
            break;                /* printf("Composite - needs a BUS\n"); */
        case integer:
        case boolean:
        case enumerated:
        case real:
            ans = 1;
            break;                /* printf("Native: needs a basic type\n"); */
        default:
            ans = -1;
            break;                /* printf("Unset\n"); */
    }
    return ans;
}

/* Generate an mFile setting up Simulink tunable parameters: place variables
 * on the matlab workspace and instruct the code generator to generate a global
 * variable for each of them.
 */
bool Tunable_Parameters (FV *fv)
{
    FILE *mTunable   = NULL;
    bool has_tunable = false;

    FOREACH (cp, Context_Parameter, fv->context_parameters, {
        if (!strcmp (cp->type.name, "Simulink-Tunable-Parameter")) {
            if (false == has_tunable) {
                char *path = make_string ("%s/%s", OUTPUT_PATH, fv->name);
                assert (NULL != path);
                has_tunable = true;
                create_file (path, "tunable_parameters.m", &mTunable);
                free (path);
                assert (NULL != mTunable);
                fprintf (mTunable,  "%% This file was automatically generated by TASTE - DO NOT EDIT -\n\n"
                                    "%% It contains the list of Simulink tunable parameters that set up\n"
                                    "%% global variables in the Matlab workspace. You can use them\n"
                                    "%% in your Simulink model and monitor them/patch them at runtime\n"
                                    "%% using TASTE Peekpoke feature (see documentation).\n"
                                    "%% If you need to modify the variable default value, open the TASTE\n"
                                    "%% interface view of your system, double click on the corresponding\n"
                                    "%% Simulink function, go to the \" Functional States\" tab, and edit.\n\n"); 
            }
            fprintf (mTunable, "%s = Simulink.Parameter;\n", cp->name);
            fprintf (mTunable, "%s.RTWInfo.StorageClass = 'ExportedGlobal';\n", cp->name);
            fprintf (mTunable, "%s.Value = %s\n", 
                cp->name, 
                cp->value);
        }
    });

    if (has_tunable) {
        fclose (mTunable);
    }
        
    return has_tunable;
}


void New_Simulink_Block(Interface * i)
{
    FILE *mFile;                /* The .m file with the appropriate commands to build the system. */
    char *suffixed;             /* string to form the full file's name */

    FILE *mFileBusSel;          /* The .m file that contains the Matlab function to set the outputs of the BusSelectors */
    char *fileNameBusSel;       /* Name of the file declared above (mFileBusSel) */
    FILE *mFileBusCrea;         /* The .m file that contains the Matlab function to set the inputs of the BusCreators */
    char *fileNameBusCrea;      /* Name of the file declared above (mFileBusCrea) */

    Parameter_list *tmp;
    size_t nameLength;

    int portSizeX, portSizeY;   /* variables to keep the port-icons' width and height */
    int busSizeX, busSizeY;     /* variables to keep the bus-icons' width and height */
    int posX, posY;             /* variables to keep the icons' position */

    char *path = NULL;

    /* Count the inports */
    tmp = i->in;
    int count_in = 0;

    while (tmp != NULL) {
        count_in = count_in + 1;
        tmp = tmp->next;
    }

    /* Count the outports */
    tmp = i->out;
    int count_out = 0;

    while (tmp != NULL) {
        count_out = count_out + 1;
        tmp = tmp->next;
    }

    if (NULL != i->parent_fv->system_ast->context->output) {
        build_string(&path, i->parent_fv->system_ast->context->output,
                     strlen(i->parent_fv->system_ast->context->output));
    }
    build_string(&path, i->parent_fv->name, strlen(i->parent_fv->name));

    /*
     * Allocate memory for below used strings ...
     */

    if (qgenc == i->parent_fv->language || qgenada == i->parent_fv->language) {
        nameLength = strlen(i->name) + strlen("_script.m");
        /* -->  suffixed <-- */
        suffixed = (char *) malloc(nameLength * sizeof(char) + 1); 
        assert (NULL != suffixed);
        
        /* form the exact file names of the .m anf the .mdl file */
        sprintf(suffixed, "%s_script.m", i->name);
    } else {
        nameLength = strlen(i->parent_fv->name) + strlen("_script.m");
        /* -->  suffixed <-- */
        suffixed = (char *) malloc(nameLength * sizeof(char) + 1); 
        assert (NULL != suffixed);
        
        /* form the exact file names of the .m anf the .mdl file */
        sprintf(suffixed, "%s_script.m", i->parent_fv->name);
    } 

    /*
     * Create and open the .m file
     */
    create_file(path, suffixed, &mFile);
    assert (NULL != mFile);

    /* If user specified tunable parameters, run the corresponding script to update Matlab workspace */
    if (true == Tunable_Parameters(i->parent_fv))
        fprintf (mFile, "run tunable_parameters;\n");

    /*
     * Call and run the matlab file containing the specification of the datatypes
     * This file is generated by the asn2datamodel tool and is always called Simulink_DataView_asn.m
     */
    fprintf(mFile, "run Simulink_DataView_asn;\n\n");

        /* create arrays for saving blocks positions */
    fprintf(mFile, "inports_positions = zeros(%d, 4);\n", count_in);
    fprintf(mFile, "bussel_positions = zeros(%d, 4);\n", count_in);
    fprintf(mFile, "outports_positions = zeros(%d, 4);\n", count_out);
    fprintf(mFile, "buscre_positions = zeros(%d, 4);\n\n", count_out);

    /*
     * Check the existance of the .mdl file.
     */

    /* a model with the same name already exists in matlab's path */
    fprintf(mFile, "if (exist('%s') == 4),\n", i->name);        /* check if an mdl file with the given model name already exists */
    fprintf(mFile, "\tsimulink('open');\n");    /* start simulink */
    fprintf(mFile, "\tload_system('%s');\n", i->name);  /* load the desired system */
    fprintf(mFile, "\topen_system('%s');\n", i->name);  /* open the system */

    /* 1. find all the existing Inports and Outports: */

    /* create a handlers' array of system's inports objects */
    fprintf(mFile,
            "\tinportHan = find_system('%s','FindAll','on', 'SearchDepth', 1, 'BlockType','Inport');\n",
            i->name);
    /* create a handlers' array of system's outports objects */
    fprintf(mFile,
            "\toutportHan = find_system('%s','FindAll','on', 'SearchDepth', 1, 'BlockType','Outport');\n",
            i->name);

    /* 2. check inports first, along with their type Bus Selectors and lines */
    /*    print a message in the .m file */
    fprintf(mFile,
            "\t%% ---------------------------------------------------------------------------------\n");
    fprintf(mFile,
            "\t%% start by removing the Bus Selectors / then lines / finally ports \n");
    fprintf(mFile,
            "\t%% ---------------------------------------------------------------------------------\n");
    fprintf(mFile,
            "\t%% get the handles of all the lines connected to inports \n");
    /* for (all the Inports of the model get the structures that define the lines going out of them) */
    fprintf(mFile, "\tfor i=1:length(inportHan)\n");
    fprintf(mFile, "\t\tinports_positions(i,:) = get_param(inportHan(i),'Position'); %% remember Inport's position\n");
    fprintf(mFile,
            "\t\tline_structsIn(i)=get_param(inportHan(i),'LineHandles'); %% get the structures\n");
    fprintf(mFile,
            "\t\tinLinesHan(i)=line_structsIn(i).Outport;\t%% get the line connected to the block's Outport\n");
    fprintf(mFile, "\t\tif (inLinesHan(i) ~= -1) %% if exists\n");
    /* get the line's destination block */
    fprintf(mFile,
            "\t\t\tdstBlock = get_param(inLinesHan(i),'DstBlockHandle'); %% get the destination block's handle\n");
    /* if the block is a Bus Selector ... */
    fprintf(mFile,
            "\t\t\tif (strcmp(get_param(dstBlock,'BlockType'),'BusSelector'))\n");
    fprintf(mFile, "\t\t\t\tbussel_positions(i,:) = get_param(dstBlock,'Position'); %% remember Bus Selector's position\n");
    /* (1)... find the lines connected to it ... */
    fprintf(mFile,
            "\t\t\t\tblockLineStructs = get_param(dstBlock,'LineHandles'); %% get the line connected structures\n");
    fprintf(mFile,
            "\t\t\t\tblockLineHandles = blockLineStructs.Outport; %% get the line handlers connected to the bus's outports\n");

    /* ... and for every line handler that corresponds to a line ... */
    fprintf(mFile, "\t\t\t\tfor j=1:length(blockLineHandles)\n");
    fprintf(mFile, "\t\t\t\t\tif (blockLineHandles(j) ~= -1)\n");
    /* ... delete the line. */
    fprintf(mFile, "\t\t\t\t\t\tdelete(blockLineHandles(j));\n");
    fprintf(mFile, "\t\t\t\t\tend\n");
    fprintf(mFile, "\t\t\t\tend\n");
    /* (2) delete the Bus Selector */
    fprintf(mFile,
            "\t\t\t\tdelete_block(dstBlock); %% delete it if it is a Bus Selector Block\n");
    fprintf(mFile, "\t\t\tend\n");
    /* (3) delete the line starting from the Inport Block's Outport */
    fprintf(mFile,
            "\t\t\tdelete(inLinesHan(i)); %% delete the respective line\n");
    fprintf(mFile, "\t\tend\n");
    /* Finally delete the Inport */
    fprintf(mFile,
            "\t\tdelete_block(inportHan(i)); %% delete the outdated inport block\n");
    fprintf(mFile, "\tend\n");

    /* 3. now check outports (following the same procedure) */
    fprintf(mFile, "\t%% now remove the outports\n");
    fprintf(mFile, "\tfor i=1:length(outportHan)\n");
    fprintf(mFile, "\t\toutports_positions(i,:) = get_param(outportHan(i),'Position'); %% remember Outport's position\n");
    fprintf(mFile,
            "\t\tline_structsOut(i)=get_param(outportHan(i),'LineHandles'); %% get the structures\n");
    fprintf(mFile,
            "\t\toutLinesHan(i)=line_structsOut(i).Inport;\t%% get the line connected to the block's Inport\n");
    fprintf(mFile, "\t\tif (outLinesHan(i) ~= -1) %% if exists\n");
    /* get the line's source block */
    fprintf(mFile,
            "\t\t\tsrcBlock = get_param(outLinesHan(i),'SrcBlockHandle'); %% get the source block's handle\n");

    /* if the block is a Bus Creator ... */
    fprintf(mFile,
            "\t\t\tif (strcmp(get_param(srcBlock,'BlockType'),'BusCreator'))\n");
    fprintf(mFile, "\t\t\t\tbuscre_positions(i,:) = get_param(srcBlock,'Position'); %% remember Bus Creator's position\n");
    /* (1)... find the lines connected to it ... */
    fprintf(mFile,
            "\t\t\t\tblockLineStructs = get_param(srcBlock,'LineHandles'); %% get the line connected structures\n");
    fprintf(mFile,
            "\t\t\t\tblockLineHandles = blockLineStructs.Inport; %% get the line handlers connected to the bus's outports\n");

    /* ... and for every line handler that corresponds to a line ... */
    fprintf(mFile, "\t\t\t\tfor j=1:length(blockLineHandles)\n");
    fprintf(mFile, "\t\t\t\t\tif (blockLineHandles(j) ~= -1)\n");
    /* ... delete the line. */
    fprintf(mFile, "\t\t\t\t\t\tdelete(blockLineHandles(j));\n");
    fprintf(mFile, "\t\t\t\t\tend\n");
    fprintf(mFile, "\t\t\t\tend\n");
    /* (2) delete the Bus Creator */
    fprintf(mFile,
            "\t\t\t\tdelete_block(srcBlock); %% delete it if it is a Bus Creator Block\n");
    fprintf(mFile, "\t\t\tend\n");
    /* (3) delete the line starting from the Inport Block's Outport */
    fprintf(mFile,
            "\t\t\tdelete(outLinesHan(i)); %% delete the respective line\n");
    fprintf(mFile, "\tend\n");
    /* Finally, delete the Outport */
    fprintf(mFile,
            "\t\tdelete_block(outportHan(i)); %% delete the outdated outport block\n");
    fprintf(mFile, "\tend\n");
    /* this is the FIRST TIME the model is created */
    fprintf(mFile, "else\n");
    fprintf(mFile, "\tsimulink('open');\n");    /* start simulink */
    fprintf(mFile, "\tnew_system('%s');\n", i->name);   /* create a new system with the desired name */
    fprintf(mFile, "\topen_system('%s');\n", i->name);  /* open the system just created */
    fprintf(mFile, "end\n");

    /*
     * create system's ports
     */

    /* Create the Inports blocks */
    tmp = i->in;
    portSizeX = 30;
    portSizeY = 14;
    busSizeX = 5;
    busSizeY = 38;
    posX = 25;
    posY = 25;
    int idx = 0;

    while (tmp != NULL) {
        idx = idx + 1;

        /* create inport */
        fprintf(mFile, "add_block('simulink/Sources/In1','%s/%s');\n",
                i->name, tmp->value->name);

        /* set port icon's position and size */
        fprintf(mFile, "if inports_positions(%d)>0\n", idx);
        fprintf(mFile, "\tset_param('%s/%s','Position', inports_positions(%d,:));\n",
                i->name, tmp->value->name, idx);
        fprintf(mFile, "else\n");
        fprintf(mFile, "\tset_param('%s/%s','Position',[%d %d %d %d]);\n",
                i->name, tmp->value->name, posX, posY, posX + portSizeX,
                posY + portSizeY);
        fprintf(mFile, "end\n");

        /* set BusOutputAsStruct to 'on' */
        fprintf(mFile, "set_param('%s/%s','BusOutputAsStruct','on');\n",
                i->name, tmp->value->name);

        /* COMPLEX type (e.g.NOT  enum, real, int, boolean), then use a bus! */
        if (!isOfBasicType(tmp->value)) {

            /* set the properties specification by bus object to 'on' */
            fprintf(mFile, "set_param('%s/%s','UseBusObject','on');\n",
                    i->name, tmp->value->name);
            /* set the asn1 type of the bus object for validating input bus */
            fprintf(mFile, "set_param('%s/%s','BusObject','%s');\n",
                    i->name, tmp->value->name, tmp->value->type);

            /* create the respective type's bus and a line from the port to the bus */
            fprintf(mFile,
                    "add_block('simulink/Commonly Used Blocks/Bus Selector','%s/%s_%s_BusSel');\n",
                    i->name, tmp->value->name, tmp->value->type);
            fprintf(mFile, "add_line('%s','%s/1','%s_%s_BusSel/1');\n",
                    i->name, tmp->value->name, tmp->value->name,
                    tmp->value->type);
            /* set BUS selector outputs to be consistent with the complex type fields */
            fprintf(mFile,
                    "setOutputsBusSelector(%s, '%s/%s_%s_BusSel');\n",
                    tmp->value->type, i->name, tmp->value->name,
                    tmp->value->type);
            /* set BUS icon's position and size */
            fprintf(mFile, "if bussel_positions(%d)>0\n", idx);
            fprintf(mFile,
                    "\tset_param('%s/%s_%s_BusSel','Position', bussel_positions(%d,:));\n",
                    i->name, tmp->value->name, tmp->value->type, idx);
            fprintf(mFile, "else\n");
            fprintf(mFile,
                    "\tset_param('%s/%s_%s_BusSel','Position',[%d %d %d %d]);\n",
                    i->name, tmp->value->name, tmp->value->type,
                    (posX + 70), posY - busSizeY / 2,
                    (posX + 70) + busSizeX, posY + busSizeY / 2);
            fprintf(mFile, "end\n");

        }
        /* BASIC type (and if the function did not fail returning -1 ) */
        else if (isOfBasicType(tmp->value) != -1) {
            fprintf(mFile, "set_param('%s/%s','DataType','Specify via Dialog');\n", i->name, tmp->value->name); /* set inport's asn1 type */
            fprintf(mFile, "set_param('%s/%s','OutDataType','%s');\n",
                    i->name, tmp->value->name, tmp->value->type);
        }
        /* TODO: else: cover the occasion when the function will fail */
        tmp = tmp->next;
        posY += 100;            /* increment posY for 100 at a time */
    }

    /* Create the Outports blocks */
    tmp = i->out;
    posX = 430, posY = 25;
    idx = 0;

    while (tmp != NULL) {
        idx = idx + 1;

        /* create the outport */
        fprintf(mFile, "add_block('simulink/Sinks/Out1','%s/%s');\n",
                i->name, tmp->value->name);

        /* set port icon's position and size */
        fprintf(mFile, "if outports_positions(%d)>0\n", idx);
        fprintf(mFile, "\tset_param('%s/%s','Position', outports_positions(%d,:));\n",
                i->name, tmp->value->name, idx);
        fprintf(mFile, "else\n");
        fprintf(mFile, "\tset_param('%s/%s','Position',[%d %d %d %d]);\n",
                i->name, tmp->value->name, posX, posY, posX + portSizeX,
                posY + portSizeY);
        fprintf(mFile, "end\n");

        /* COMPLEX type */
        if (!isOfBasicType(tmp->value)) {
            fprintf(mFile, "set_param('%s/%s','UseBusObject','on');\n",
                    i->name, tmp->value->name);
            fprintf(mFile, "set_param('%s/%s','BusObject','%s');\n",
                    i->name, tmp->value->name, (tmp->value->type));

            /* create the respective type's bus and a line from the bus to the port */
            fprintf(mFile,
                    "add_block('simulink/Commonly Used Blocks/Bus Creator','%s/%s_%s_BusCre');\n",
                    i->name, tmp->value->name, tmp->value->type);
            fprintf(mFile, "add_line('%s','%s_%s_BusCre/1','%s/1');\n",
                    i->name, tmp->value->name, tmp->value->type,
                    tmp->value->name);
            /* set BUS creator inputs to be consistent with the name of the complex type fields */
            fprintf(mFile, "setInputsBusCreator(%s,'%s/%s_%s_BusCre');\n",
                    tmp->value->type, i->name, tmp->value->name,
                    tmp->value->type);

            /* set the properties specification by bus object to 'on' */
            fprintf(mFile, "set_param('%s/%s','UseBusObject','on');\n",
                    i->name, tmp->value->name);

            /* set the NonVirtualBus to 'on' */
            fprintf(mFile, "set_param('%s/%s','BusOutputAsStruct','on');\n",
                    i->name, tmp->value->name);

            /* set BUS object with the name of the complex type */
            fprintf(mFile,
                    "set_param('%s/%s_%s_BusCre','BusObject','%s');\n",
                    i->name, tmp->value->name, tmp->value->type,
                    tmp->value->type);
            /* set BUS icon's position and size */
            fprintf(mFile, "if buscre_positions(%d)>0\n", idx);
            fprintf(mFile,
                    "\tset_param('%s/%s_%s_BusCre','Position', buscre_positions(%d,:));\n",
                    i->name, tmp->value->name, tmp->value->type, idx);
            fprintf(mFile, "else\n");
            fprintf(mFile,
                    "\tset_param('%s/%s_%s_BusCre','Position',[%d %d %d %d]);\n",
                    i->name, tmp->value->name, tmp->value->type,
                    (posX - 70), posY - busSizeY / 2,
                    (posX - 70) + busSizeX, posY + busSizeY / 2);
            fprintf(mFile, "end\n");

            /* set UseBusObject flag to ON */
            fprintf(mFile,
                    "set_param('%s/%s_%s_BusCre','UseBusObject','on');\n",
                    i->name, tmp->value->name, tmp->value->type);
            /* set NonVirtualBus flag to ON */
            fprintf(mFile,
                    "set_param('%s/%s_%s_BusCre','NonVirtualBus','on');\n",
                    i->name, tmp->value->name, tmp->value->type);

        }
        /* BASIC type (and if the function did not fail returning -1 ) */
        else if (isOfBasicType(tmp->value) != -1) {
            fprintf(mFile, "set_param('%s/%s','DataType','Specify via Dialog');\n", i->name, tmp->value->name); /* set inport's asn1 type */
            fprintf(mFile, "set_param('%s/%s','OutDataType','%s');\n",
                    i->name, tmp->value->name, tmp->value->type);;
        }
        /* TODO: else: cover the occasion when the function will fail */

        tmp = tmp->next;
        posY += 100;            /* increment posY for 100 at a time */
    }

    /*
     * Set the system's parameters
     */

    fprintf(mFile, "set_param('%s','SaveOutput','off');\n", i->name);   /* Disable output saving , signal logging and time saving. */
    fprintf(mFile, "set_param('%s','SignalLogging','off');\n", i->name);
    fprintf(mFile, "set_param('%s','SaveTime','off')\n", i->name);

    fprintf(mFile, "set_param('%s','Solver','FixedStepDiscrete');\n", i->name); /* Chose solver type for the code generation. */

    fprintf(mFile, "set_param('%s','SystemTargetFile','ert.tlc');\n", i->name); /* Chose System target file. */
    fprintf(mFile, "set_param('%s','TemplateMakefile','ert_default_tmf');\n", i->name); /* Chose makefile template.*/
    /* Added by MA Esteve ion the 15th of Julky 2009 */
    fprintf(mFile, "set_param('%s', 'PostCodeGenCommand', 'packNGo(buildInfo);');\n", i->name); /* Will allow packaging code files generated. */

    /* Newer Matlab (R2015a) complains about this setting being on Warning */
    fprintf(mFile, "set_param('%s','StrictBusMsg','ErrorLevel1')\n", i->name);

    fprintf(mFile, "save_system('%s');\n", i->name);    /* save the system created */
    fprintf(mFile, "close_system('%s');\n", i->name);   /* close the system */
    fprintf(mFile, "simulink('close');\n");     /* close simulink */

    close_file(&mFile);

    /*
     * Allocate memory for below used strings ...
     */
    nameLength = strlen("setOutputsBusSelector.m");
    /* -->  fileNameBusSel <-- */
    if ((fileNameBusSel =
         (char *) malloc(nameLength * sizeof(char) + 1)) == NULL) {
        fprintf(stderr,
                "Error: Unable to allocate memory for string.\nAborting...\n");
        return;
    }

    /* form the exact file names of the .m file */
    sprintf(fileNameBusSel, "setOutputsBusSelector.m");

    /*
     * Create and open the .m file containing the function 'setOutputsBusSelector' to set the outputs of the created bus selectors
     */
    create_file(path, fileNameBusSel, &mFileBusSel);
    if (NULL == mFileBusSel) {
        fprintf(stderr,
                "Error: Unable to open file \"%s\" for writing.\nAborting...\n",
                fileNameBusSel);
        return;
    }

    fprintf(mFileBusSel, "function []=setOutputsBusSelector(in_type, in_busSel)\n");    /* Declaration of the function */
    fprintf(mFileBusSel, "\tif(isa(in_type, 'Simulink.Bus'))\n");
    fprintf(mFileBusSel, "\t\ts='';\n");
    fprintf(mFileBusSel, "\t\tfor i=1:length(in_type.Elements)\n");
    fprintf(mFileBusSel, "\t\t\ts=strcat(s,in_type.Elements(i).name);\n");
    fprintf(mFileBusSel, "\t\t\tif i < length(in_type.Elements)\n");
    fprintf(mFileBusSel, "\t\t\t\ts=strcat(s, ',');\n");
    fprintf(mFileBusSel, "\t\t\tend\n");
    fprintf(mFileBusSel, "\t\tend\n");
    fprintf(mFileBusSel,
            "\t\tset_param(in_busSel, 'OutputSignals', s);\n");
    fprintf(mFileBusSel, "\tend\n");

    close_file(&mFileBusSel);

    /*
     * Allocate memory for below used strings ...
     */
    nameLength = strlen("setInputsBusCreator.m");
    /* -->  fileNameBusCrea <-- */
    if ((fileNameBusCrea =
         (char *) malloc(nameLength * sizeof(char) + 1)) == NULL) {
        fprintf(stderr,
                "Error: Unable to allocate memory for string.\nAborting...\n");
        return;
    }
    /* form the exact file names of the .m file */
    sprintf(fileNameBusCrea, "setInputsBusCreator.m");
    /*
     * Create and open the .m file containing the function 'setInputsBusCreator' to set the inputs of the created bus creators
     */
    create_file(path, fileNameBusCrea, &mFileBusCrea);
    if (NULL == mFileBusCrea) {
        fprintf(stderr,
                "Error: Unable to open file \"%s\" for writing.\nAborting...\n",
                fileNameBusCrea);
        return;
    }

    fprintf(mFileBusCrea, "function []=setInputsBusCreator(in_type, in_busCrea)\n");    /* Declaration of the function */
    fprintf(mFileBusCrea, "\tif(isa(in_type, 'Simulink.Bus'))\n");
    fprintf(mFileBusCrea, "\t\ts='';\n");
    fprintf(mFileBusCrea, "\t\tif(length(in_type.Elements)==1);\n");
    fprintf(mFileBusCrea, "\t\t\tset_param(in_busCrea, 'Inputs', '1');\n");
    fprintf(mFileBusCrea, "\t\telse");
    fprintf(mFileBusCrea, "\t\t\tfor i=1:length(in_type.Elements)\n");
    fprintf(mFileBusCrea,
            "\t\t\t\ts=strcat(s,in_type.Elements(i).name);\n");
    fprintf(mFileBusCrea, "\t\t\t\tif i < length(in_type.Elements)\n");
    fprintf(mFileBusCrea, "\t\t\t\t\ts=strcat(s, ',');\n");
    fprintf(mFileBusCrea, "\t\t\t\tend\n");
    fprintf(mFileBusCrea, "\t\t\tend\n");
    fprintf(mFileBusCrea, "\t\t\tset_param(in_busCrea, 'Inputs', s);\n");
    fprintf(mFileBusCrea, "\t\tend\n");
    fprintf(mFileBusCrea, "\tend\n");

    close_file(&mFileBusCrea);

    return;

}



/* Check Test Mode (Request from Semantix 28/04/2009)
    For a given interface, check that all INPUT parameters match an OUTPUT parameter with the exact same type    
    Returns -1 in case of problem (don't match or not same number of inputs and outputs)
*/
int CheckTestMode(Interface * i)
{
    int count_in = 0;
    int count_out = 0;
    Parameter_list *p_result = i->out;

    FOREACH(p, Parameter, i->in, {
        (void) p;
        count_in++;
    })
    FOREACH(p, Parameter, i->out, {
        (void) p;
        count_out++;
    })

    if (count_in != count_out)
        return -1;     /* not the same number of input and output parameters */

    FOREACH(p, Parameter, i->in, {
        if (false == CheckInOutParams(p, p_result)) return -1;
    })

    return 0;
}


void GW_Simulink_Interface(Interface * i)
{
    if (i->parent_fv->system_ast->context->test && 0 == CheckTestMode(i)) {
        printf
            ("*** simulink test mode *** input and outputs are compatible \n");
    }

    New_Simulink_Block(i);
}

/* External interface (the one and unique) */
void GW_Simulink_Backend(FV * fv)
{
    if (fv->system_ast->context->onlycv)
        return;

    if (fv->system_ast->context->test)
        printf
            ("*** simulink test mode: if inputs and outputs have the same type, they will be directly connected ***\n");

    if (simulink == fv->language || qgenc == fv->language || qgenada == fv->language) {
                                        /* Can there be more than one interface to a simulink block ?? 
                                        *  (question MP 28/04/2009) No, prevented by semantic checks...(MP 26/07/2010) */
        FOREACH(i, Interface, fv->interfaces, {
            GW_Simulink_Interface(i);
        })
    }
}
